function timestampToDate(timestamp) {
  var result = new Date(0);
  result.setUTCSeconds(timestamp);
  return result;
}

function allignTimestampToMonth(timestamp) {
  function padMonth(month) {
    if (month < 10) {
      return "0" + month;
    } else {
      return "" + month;
    }
  }
  var date = timestampToDate(timestamp);
  return new Date(date.getUTCFullYear() + "-" + padMonth(date.getUTCMonth() + 1) + "-01T00:00:00Z");
}

function allignTimestampToDay(timestamp) {
  var timeGranularity = 1 * 60 * 60 * 24; //1d
  return timestampToDate(Math.floor((timestamp) / timeGranularity) * timeGranularity);
}

function allignTimestampToWeek(timestamp) {
  var timeShift = 4 * 60 * 60 * 24; // epoch is Thursday
  var timeGranularity = 7 * 60 * 60 * 24; //1d
  return timestampToDate(Math.floor((timestamp + timeShift) / timeGranularity) * timeGranularity + timeShift - 7 * 60 * 60 * 24);
}

function allignTimestamp(timestamp) {
  if (params.unit == 'day') {
    return allignTimestampToDay(timestamp);
  } else if (params.unit == 'week') {
    return allignTimestampToWeek(timestamp);
  } else if (params.unit == 'month') {
    return allignTimestampToMonth(timestamp);
  } else {
    return new Date();
  }
}

function deploymentsFilter(e) {
  task = e.properties.task;
  return task.startsWith("stage_and_deploy") || task.startsWith("deploy") || task.startsWith("copy_artifact");
}

function countElapsedReducer(a, b) {
  result = {elapsed: 0, count: 0};
  for (var i in a) {
    result.elapsed += a[i].elapsed;
    result.count += a[i].count;
  }
  
  for (i in b) {
    result.count += 1;
    result.elapsed += b[i].properties.elapsed_sec;
  }
  
  return result;
}

function reduceOnFirstField(a, b) {
  result = {};
  
  for (var i in a) {
    for (var k in a[i]) {
      if (!result.hasOwnProperty(k)) {
        result[k] = {};
      }
      for (var l in a[i][k]) {
        if (!result[k].hasOwnProperty(l)) {
          result[k][l] = a[i][k][l];
        } else {
          result[k][l] += a[i][k][l];
        }
      }
    }
  }
  for (var i in b) {
    key = b[i].key[1];
    if (!result.hasOwnProperty(key)) {
      result[key] = {};
    }
    for (var l in b[i].value) {
      if (!result[key].hasOwnProperty(l)) {
        result[key][l] = b[i].value[l];
      } else {
        result[key][l] += b[i].value[l];
      }
    }
  }
  return result;
}

function fillDateGaps(t) {
  var current = Date.parse(params.from_date) / 1000;
  var end = Date.parse(params.to_date) / 1000;
  var v = {};
  while (current <= end) {
    var currentDateKey = allignTimestamp(current).toISOString().split('T')[0];
    var currentDate = timestampToDate(current).toISOString();
    if (!v.hasOwnProperty(currentDateKey)) {
      v[currentDateKey] = {elapsed:0, count:0};
    }
    if (t.value.hasOwnProperty(currentDate)) {
      v[currentDateKey].elapsed += t.value[currentDate].elapsed;
      v[currentDateKey].count += t.value[currentDate].count;
    }
    current += 24 * 60 * 60;
  }
  t.value = v;
  return t;
}


function main() {
  return Events({
    from_date: params.from_date,
    to_date: params.to_date,
    event_selectors: [{'event': 'Fabric command'}]
  })
  .filter(deploymentsFilter)
  .groupBy(["properties.task", function (e) {return allignTimestampToDay(e.time / 1000)}], countElapsedReducer)
  .groupBy([function (e) {return e.key[0]}], reduceOnFirstField)
  .map(fillDateGaps)
  ;
}